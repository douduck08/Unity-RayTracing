#pragma kernel InitCameraRays
#pragma kernel RayTracing
#pragma kernel NormalizeSamples

#include "RayTracing.cginc"

RWTexture2D<float4> result;
float4 renderParameter;
float4x4 cameraRayParameter;

int sphereNumber;
StructuredBuffer<SphereData> sphereBuffer;

Ray CreateCameraRay (float2 uv) {
    return CreateRay(cameraRayParameter[0].xyz, cameraRayParameter[1].xyz + uv.x * cameraRayParameter[2].xyz + uv.y * cameraRayParameter[3].xyz);
}

bool SampleColor (Ray ray, out float3 color, out Ray next_ray) {
    RayHit hit, tmp_hit;
    hit.t = 1000.0;
    bool hit_something = false;
    int sphere_id;
    for (int i = 0; i < sphereNumber; i++) {
        if (HitSphere(ray, sphereBuffer[i], 0.001, hit.t, /*out*/tmp_hit)) {
            hit_something = true;
            hit = tmp_hit;
            sphere_id = i;
        }
    }
    if (hit_something) {
        color = sphereBuffer[sphere_id].color.rgb * 0.9; // TODO: metallic
        next_ray = CreateRay(hit.position, hit.normal + RandInUnitSphere (hit.normal));
    } else {
        color = float3(0.5, 0.7, 1);
        next_ray = (Ray)0;
    }
    return hit_something;
}

float3 GetColorAt (float2 uv) {
    Ray ray = CreateCameraRay(uv);
    bool need_sample = true;
    int depth;
    float3 final_color = 1, sample_color;
    while (need_sample && depth < 50) {
        need_sample = SampleColor (ray, /*out*/sample_color, /*out*/ray);
        final_color *= sample_color;
        depth += 1;
    }
    return final_color;
}

float3 GammaToLinearSpace (float3 sRGB) {
    // Approximate version from http://chilliant.blogspot.com.au/2012/08/srgb-approximations-for-hlsl.html?m=1
    return sRGB * (sRGB * (sRGB * 0.305306011h + 0.682171111h) + 0.012522878h);
}

[numthreads(8,8,1)]
void InitCameraRays (uint3 id : SV_DispatchThreadID) {

}

[numthreads(8,8,1)]
void RayTracing (uint3 id : SV_DispatchThreadID) {
    float2 uv = float2(renderParameter.z * id.x, renderParameter.w * id.y);

    float3 color = 0;
    color += GetColorAt(uv);
    color += GetColorAt(uv + float2(renderParameter.z * 0.5, 0));
    color += GetColorAt(uv + float2(0, renderParameter.w * 0.5));
    color += GetColorAt(uv + float2(renderParameter.z * 0.5, renderParameter.w * 0.5));
    color = color * 0.25;

    color = GammaToLinearSpace(color);

    result[id.xy] = float4(color, 0);
}

[numthreads(8,8,1)]
void NormalizeSamples (uint3 id : SV_DispatchThreadID) {

}