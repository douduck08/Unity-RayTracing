#pragma kernel InitCameraRays
#pragma kernel RayTrace
#pragma kernel NormalizeSamples

#include "UnityCG.cginc"
#include "Common.cginc"
#include "RayTracingStruct.cginc"

#define MIN_RAY_DISTANCE 0.001
#define MAX_RAY_DISTANCE 1000.0
#define MAX_RAY_STEP 50

RWTexture2D<float4> result;
RWStructuredBuffer<Ray> rayBuffer;
float4x4 cameraFrustumCorners;

int sphereNumber;
StructuredBuffer<SphereData> sphereBuffer;

int planeNumber;
StructuredBuffer<PlaneData> planeBuffer;

bool RayCast(Ray ray, out RayHit hit) {
    hit = (RayHit)0;
    hit.t = MAX_RAY_DISTANCE;

    bool hit_something = false;
    int i = 0;
    for (i = 0; i < sphereNumber; i++) {
        if (ray.HitSphere(sphereBuffer[i], MIN_RAY_DISTANCE, hit.t, /*out*/hit)) hit_something = true;
    }
    for (i = 0; i < planeNumber; i++) {
        if (ray.HitPlane(planeBuffer[i], MIN_RAY_DISTANCE, hit.t, /*out*/hit)) hit_something = true;
    }
    return hit_something;
}

float3 SampleEnvColor (float3 direction) {
    return float3(0.5, 0.7, 1);
}

bool SampleColor (Ray ray, out Ray scattered_ray) {
    RayHit hit;
    bool hit_something = RayCast(ray, /*out*/hit);

    if (hit_something) {
        hit_something = Scatter(ray, hit, /*out*/scattered_ray);
        // ** debug **
        // hit_something = false;
        // scattered_ray = (Ray)0;
        // scattered_ray.color = hit.normal * 0.5 + 0.5;
        // scattered_ray.color = hit.position;
        // ** debug **
    }
    else {
        scattered_ray = (Ray)0;
        scattered_ray.color = ray.color * SampleEnvColor(ray.direction);
    }
    return hit_something;
}

[numthreads(8,8,1)]
void InitCameraRays (uint3 id : SV_DispatchThreadID) {
    uint width, height;
    result.GetDimensions(width, height);

    int rayIndex = id.x + width * id.y + width * height * id.z;
    float2 texelSize = rcp(float2(width, height));
    float2 uv = float2(id.x * texelSize.x, id.y * texelSize.y);

    float r = Rand(float2(sin(_Time.x + id.z), sin(_Time.y + id.z)));
    uv += Rand(uv + r) * texelSize;

    float3 dir = cameraFrustumCorners[0].xyz + uv.x * (cameraFrustumCorners[3].xyz - cameraFrustumCorners[0].xyz) + uv.y * (cameraFrustumCorners[1].xyz - cameraFrustumCorners[0].xyz);

    Ray ray = CreateRay(_WorldSpaceCameraPos, dir);
    rayBuffer[rayIndex] = ray;
}

[numthreads(8,8,1)]
void RayTrace (uint3 id : SV_DispatchThreadID) {
    uint width, height;
    result.GetDimensions(width, height);
    
    int rayIndex = id.x + width * id.y + width * height * id.z;
    float2 texelSize = rcp(float2(width, height));

    Ray ray = rayBuffer[rayIndex];
    int depth;
    bool hit_something = true;
    while (hit_something && depth < MAX_RAY_STEP) {
        hit_something = SampleColor (ray, /*out*/ray);
        depth += 1;
    }

    if (depth >= MAX_RAY_STEP) {
        // over the max bounces
        ray.color = 0;
    }

    rayBuffer[rayIndex] = ray;
}

[numthreads(8,8,1)]
void NormalizeSamples (uint3 id : SV_DispatchThreadID) {
    uint width, height;
    result.GetDimensions(width, height);

    uint rayNumber, stride;
    rayBuffer.GetDimensions(rayNumber, stride);

    uint totalPixels = width * height;
    float3 color = 0;
    int samples = 0;
    for (uint rayIndex = id.x + id.y * width; rayIndex < rayNumber; rayIndex += totalPixels) {
        color += rayBuffer[rayIndex].color;
        samples += 1;
    }

    if (samples > 0) {
        color /= samples;
        // color = GammaToLinearSpace(color);
    }

    // color = lerp(color, result[id.xy].rgb, 0.9);  // simple taa

    result[id.xy] = float4(color, 1);
}