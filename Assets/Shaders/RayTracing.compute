#pragma kernel InitCameraRays
#pragma kernel RayTracing
#pragma kernel NormalizeSamples

#include "UnityCG.cginc"
#include "RayTracingCommon.cginc"
#include "RayTracingStruct.cginc"

RWTexture2D<float4> result;
float4 renderParameter;
float4x4 cameraRayParameter;

RWStructuredBuffer<Ray> rayBuffer;

int sphereNumber;
StructuredBuffer<SphereData> sphereBuffer;

Ray CreateCameraRay (float2 uv) {
    return CreateRay(cameraRayParameter[0].xyz, cameraRayParameter[1].xyz + uv.x * cameraRayParameter[2].xyz + uv.y * cameraRayParameter[3].xyz);
}

bool SampleColor (Ray ray, out float3 color, out Ray next_ray) {
    RayHit hit, tmp_hit;
    hit.t = 1000.0;
    bool hit_something = false;
    int sphere_id;
    for (int i = 0; i < sphereNumber; i++) {
        if (HitSphere(ray, sphereBuffer[i], 0.001, hit.t, /*out*/tmp_hit)) {
            hit_something = true;
            hit = tmp_hit;
            sphere_id = i;
        }
    }
    if (hit_something) {
        color = sphereBuffer[sphere_id].color.rgb * 0.9; // TODO: metallic
        next_ray = CreateRay(hit.position, hit.normal + RandInUnitSphere (hit.normal));
    } else {
        color = float3(0.5, 0.7, 1);
        next_ray = (Ray)0;
    }
    return hit_something;
}

[numthreads(8,8,1)]
void InitCameraRays (uint3 id : SV_DispatchThreadID) {
    uint width, height;
    result.GetDimensions(width, height);

    int rayIndex = (id.x + id.y * width) + (width * height * id.z);
    float2 uv = float2(renderParameter.z * id.x, renderParameter.w * id.y);
    uv += Rand(uv + _SinTime.x) * renderParameter.zw;

    Ray ray = CreateCameraRay (uv);
    rayBuffer[rayIndex] = ray;
}

[numthreads(8,8,1)]
void RayTracing (uint3 id : SV_DispatchThreadID) {
    uint width, height;
    result.GetDimensions(width, height);

    int rayIndex = (id.x + id.y * width) + (width * height * id.z);
    float2 uv = float2(renderParameter.z * id.x, renderParameter.w * id.y);

    Ray ray = rayBuffer[rayIndex];
    bool need_sample = true;
    int depth;
    float3 color = ray.color;
    float3 sample_color;
    while (need_sample && depth < 50) {
        need_sample = SampleColor (ray, /*out*/sample_color, /*out*/ray);
        color *= sample_color;
        depth += 1;
    }
    ray.color = color;

    rayBuffer[rayIndex] = ray;
}

[numthreads(8,8,1)]
void NormalizeSamples (uint3 id : SV_DispatchThreadID) {
    uint width, height;
    result.GetDimensions(width, height);

    uint rayNumber, stride;
    rayBuffer.GetDimensions(rayNumber, stride);

    uint totalPixels = width * height;
    float3 color = 0;
    int samples = 0;
    for (uint rayIndex = id.x + id.y * width; rayIndex < rayNumber; rayIndex += totalPixels) {
        color += rayBuffer[rayIndex].color;
        samples += 1;
    }

    if (samples > 0) {
        color /= samples;
        // color = GammaToLinearSpace(color);
    }

    color = result[id.xy].rgb * 0.9 + color * 0.1;  // simple taa

    result[id.xy] = float4(color, 1);
}