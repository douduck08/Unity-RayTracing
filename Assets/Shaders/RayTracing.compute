#pragma kernel InitCameraRays
#pragma kernel RayTrace
#pragma kernel NormalizeSamples

#include "UnityCG.cginc"
#include "RayTracingCommon.cginc"
#include "RayTracingStruct.cginc"

#define MIN_RAY_DISTANCE 0.001
#define MAX_RAY_DISTANCE 1000.0

RWTexture2D<float4> result;
float4 renderParameter;
float4x4 cameraRayParameter;

RWStructuredBuffer<Ray> rayBuffer;

int sphereNumber;
StructuredBuffer<SphereData> sphereBuffer;

Ray CreateCameraRay (float2 uv) {
    return CreateRay(cameraRayParameter[0].xyz, cameraRayParameter[1].xyz + uv.x * cameraRayParameter[2].xyz + uv.y * cameraRayParameter[3].xyz);
}

float3 SampleEnvColor (float3 direction) {
    return float3(0.5, 0.7, 1);
}

bool SampleColor (inout Ray ray, out Ray scattered_ray, int reflectionMode) {
    RayHit hit, tmp_hit;
    hit.t = MAX_RAY_DISTANCE;

    bool hit_something = false;
    int sphere_id;
    for (int i = 0; i < sphereNumber; i++) {
        if (ray.HitSphere(sphereBuffer[i], MIN_RAY_DISTANCE, hit.t, /*out*/hit)) {
            hit_something = true;
            sphere_id = i;
        }
    }

    if (hit_something) {
        if (reflectionMode) {
            hit_something = ScatterReflection(ray, hit, /*out*/scattered_ray);
        } else {
            hit_something = ScatterLambertian(ray, hit, /*out*/scattered_ray);
        }
    } else {
        scattered_ray = (Ray)0;
        scattered_ray.color = ray.color * SampleEnvColor(ray.direction);
    }
    return hit_something;
}

[numthreads(8,8,1)]
void InitCameraRays (uint3 id : SV_DispatchThreadID) {
    uint width, height;
    result.GetDimensions(width, height);

    int rayIndex = (id.x + id.y * width) + (width * height * id.z);
    float2 uv = float2(renderParameter.z * id.x, renderParameter.w * id.y);
    uv += Rand(uv + _SinTime.x) * renderParameter.zw;

    Ray ray = CreateCameraRay (uv);
    rayBuffer[rayIndex] = ray;
}

[numthreads(8,8,1)]
void RayTrace (uint3 id : SV_DispatchThreadID) {
    uint width, height;
    result.GetDimensions(width, height);

    int rayIndex = (id.x + id.y * width) + (width * height * id.z);
    float2 uv = float2(renderParameter.z * id.x, renderParameter.w * id.y);

    int reflectionMode = id.z & 1;

    Ray ray = rayBuffer[rayIndex];
    int depth;
    bool hit_something = true;
    while (hit_something && depth < 50) {
        hit_something = SampleColor (ray, /*out*/ray, reflectionMode);
        depth += 1;
    }

    if (depth > 49) {
        // over the max bounces
        ray.color = 0;
    }

    rayBuffer[rayIndex] = ray;
}

[numthreads(8,8,1)]
void NormalizeSamples (uint3 id : SV_DispatchThreadID) {
    uint width, height;
    result.GetDimensions(width, height);

    uint rayNumber, stride;
    rayBuffer.GetDimensions(rayNumber, stride);

    uint totalPixels = width * height;
    float3 color = 0;
    int samples = 0;
    for (uint rayIndex = id.x + id.y * width; rayIndex < rayNumber; rayIndex += totalPixels) {
        color += rayBuffer[rayIndex].color;
        samples += 1;
    }

    if (samples > 0) {
        color /= samples;
        // color = GammaToLinearSpace(color);
    }

    color = lerp(color, result[id.xy].rgb, 0.9);  // simple taa

    result[id.xy] = float4(color, 1);
}